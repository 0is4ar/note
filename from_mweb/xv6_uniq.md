# grep

不断搜p=buf中的'\n'，就是一行
q是一行的结尾，
先标记*q=0 代表这里已经搜索过了
如果这一行里面有match(pattern, p)的
则*q = '\n' 恢复成原来的
并且printf(p,q+1-p) 代表print 这一行
然后p=q+1是 p指到这一行的下一行开头

- 需要记住的是p是比q大的，每个p-q就是一行在内存中的长度

if(p==buf)代表上一个while并没有执行任何操作
继续从fd中能读多少读多少，每一次read应该都是从上一个read读取结尾继续读

m>0代表其实是找到东西了的
m = m - (p-buf)

- 因为每次读取不会刚好读取多少行，读到一行中间了，因为此时p = q+1了，就是最靠近本次读取结尾的\n，m - (p-buf)是为了从上次断行的行首继续开始读

- 通过 p=q+1，p回到了此次读取，比整行余出来的一小段，m - (p-buf) 就是余出来的一小段的长度

- memmove(buf, p, m)就是从 余出来的半行的开头，数 buf到p的长度， 从p后移到buf

- 一次读取规定最大只能512（not sure)


